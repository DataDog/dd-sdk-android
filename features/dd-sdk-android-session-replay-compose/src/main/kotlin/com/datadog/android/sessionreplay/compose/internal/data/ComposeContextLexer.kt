/*
 * Unless explicitly stated otherwise all files in this repository are licensed under the Apache License Version 2.0.
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2016-Present Datadog, Inc.
 */

package com.datadog.android.sessionreplay.compose.internal.data

/**
 * A lexer able to parse the `sourceInfo` string generated by the Kotlin Compiler,
 * providing information about the original source code of a specific CompositionGroup.
 *
 * The lexer will parse one character at a time, via its internal TokenReader, and will
 * update the internal ComposeContext until the full input string is read, returning the final
 * version of the ComposeContext, or null if the input doesn't match the expected format.
 */
internal object ComposeContextLexer {

    private const val RADIX_BASE_10 = 10
    private const val RADIX_BASE_36 = 36

    private sealed class TokenReader {

        abstract fun process(c: Char)
        abstract fun updateComposeContext(composeContext: ComposeContext?): ComposeContext?
        protected var nextReader: TokenReader? = null

        fun nextReader() = nextReader

        protected fun nextReader(c: Char): TokenReader {
            return when (c) {
                'C' -> CallTR()
                'P' -> ParametersTR()
                '1', '2', '3', '4', '5', '6', '7', '8', '9' -> LocationTR(c)
                ':' -> SourceFileTR()
                ',' -> EmptyTR()
                '*' -> RepeatTR()
                else -> InvalidTR()
            }
        }

        /**
         * Use when an unexpected character is met while parsing. It means either the format is using an unsupported
         * or unknown feature of the `sourceInfo` string.
         */
        class InvalidTR : TokenReader() {
            override fun process(c: Char) {
            }

            override fun updateComposeContext(composeContext: ComposeContext?): ComposeContext? {
                return null
            }
        }

        /**
         * The default [TokenReader], used at the beginning of a `sourceInfo`, or when a part of the `sourceInfo`
         * has been read in full.
         */
        class EmptyTR : TokenReader() {
            override fun process(c: Char) {
                nextReader = nextReader(c)
            }

            override fun updateComposeContext(composeContext: ComposeContext?): ComposeContext? {
                return composeContext
            }
        }

        /**
         * A `*` char in the `sourceInfo` indicates a repeat of the existing [ComposeContext.locations].
         * This allows a more efficient compression and avoids duplicates in the `sourceInfo`
         */
        class RepeatTR : TokenReader() {
            override fun process(c: Char) {
                nextReader = nextReader(c)
            }

            override fun updateComposeContext(composeContext: ComposeContext?): ComposeContext? {
                return composeContext?.copy(repeatOffset = composeContext.locations.size)
            }
        }

        /**
         * A `C` char in the `sourceInfo` represents a call to a composable method.
         *
         * If it's alone, it means it's a call to an inlined function. If it's followed by a name between parenthesis,
         * it's a call to a non inlined function (e.g.: "C(Text)" means a call to the `Text()` function).
         *
         * A call to an inline function, which itself calls a named function, will be represented as e.g.: `CC(Text)`.
         */
        class CallTR : TokenReader() {

            private var isInline = false
            private var callName = ""
            private var hasClassName = false

            override fun process(c: Char) {
                if (hasClassName) {
                    if (c == ')') {
                        nextReader = EmptyTR()
                    } else {
                        callName += c
                    }
                } else if (c == 'C') {
                    isInline = true
                } else if (c == '(') {
                    hasClassName = true
                } else {
                    nextReader = nextReader(c)
                }
            }

            override fun updateComposeContext(composeContext: ComposeContext?): ComposeContext? {
                return composeContext?.copy(
                    name = if (hasClassName) callName else null,
                    isCall = true,
                    isInline = isInline
                )
            }
        }

        /**
         * Reads a source location information written with three numbers as {line}@{offset}L{length} (e.g.: "13@42L23").
         * - `line` corresponds to a 0-indexed line number in the source file;
         * - `offset` corresponds to the byte offset into the file. The offset is calculated as the number of UTF-16
         * code units from the beginning of the file to the first UTF-16 code unit of the call that produced the group.
         * - `length` is the length of the code within the source file. The length is calculated as the
         * number of UTF-16 code units that make up the call expression.
         */
        class LocationTR(initialDigit: Char) : TokenReader() {

            var line: Int = initialDigit.digitToIntOrNull() ?: 0
            var offset: Int = -1
            var length: Int = -1

            override fun process(c: Char) {
                when (c) {
                    '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' -> {
                        @Suppress("UnsafeThirdPartyFunctionCall") // char is a valid digit
                        val digit = c.digitToInt()
                        if (length >= 0) {
                            length = (length * RADIX_BASE_10) + digit
                        } else if (offset >= 0) {
                            offset = (offset * RADIX_BASE_10) + digit
                        } else {
                            line = (line * RADIX_BASE_10) + digit
                        }
                    }

                    '@' -> offset = 0
                    'L' -> length = 0

                    else -> nextReader = nextReader(c)
                }
            }

            override fun updateComposeContext(composeContext: ComposeContext?): ComposeContext? {
                // line is 0-indexed, but to be user readable, make it 1-indexed
                val sourceLocationInfo = SourceLocationInfo(line + 1, offset, length)
                return composeContext?.copy(
                    locations = composeContext.locations + sourceLocationInfo
                )
            }
        }

        /**
         *  A `P` char in the `sourceInfo` represents a list of parameters passed into the compose group.
         *
         *  The parameters are formatted as follow :
         * - `\d+` : the index ot the param as a number
         * - `\d+:inline-class`: the index ot the param as a number, followed by the inline class (which contains anything but `,` or `!`)
         * - `!\d+`: a run number (refers to the first n parameters of the call)
         */
        class ParametersTR : TokenReader() {
            var isReadingParams = false
            var params = mutableListOf<Parameter>()
            var currentNumber: Int? = null
            var isNextNumberRun = false
            var isReadingInline = false
            var inlineClass: String? = null

            @Suppress("MagicNumber")
            val expectedSortedIndex = mutableListOf(0, 1, 2, 3)
            var lastAdded = expectedSortedIndex.size - 1

            override fun process(c: Char) {
                when (c) {
                    '(' -> {
                        isReadingParams = true
                    }

                    '1', '2', '3', '4', '5', '6', '7', '8', '9', '0' -> {
                        @Suppress("UnsafeThirdPartyFunctionCall") // char is a valid digit
                        val digit = c.digitToInt()
                        currentNumber = ((currentNumber ?: 0) * RADIX_BASE_10) + digit
                    }

                    '!' -> {
                        processCurrentNumber()
                        isNextNumberRun = true
                    }

                    ',' -> {
                        processCurrentNumber()
                    }

                    ':' -> {
                        isReadingInline = true
                        inlineClass = ""
                    }

                    ')' -> {
                        processCurrentNumber()
                        nextReader = EmptyTR()
                    }

                    else -> if (isReadingInline) {
                        inlineClass += c
                    } else {
                        nextReader = InvalidTR()
                    }
                }
            }

            private fun processCurrentNumber() {
                if (currentNumber == null) return

                if (isNextNumberRun) {
                    val count = currentNumber ?: 0
                    ensureIndexes(params.size + count)
                    repeat(count) {
                        params.add(Parameter(expectedSortedIndex.removeAt(0)))
                    }
                    isNextNumberRun = false
                } else {
                    val index = currentNumber ?: 0
                    val rawClass = inlineClass
                    val composeClass = if (rawClass != null && rawClass.startsWith("c#")) {
                        @Suppress("UnsafeThirdPartyFunctionCall") // substring can't throw IndexOutOfBoundsException
                        "androidx.compose." + rawClass.substring(2)
                    } else {
                        rawClass
                    }
                    params.add(Parameter(index, composeClass))
                    ensureIndexes(index)
                    expectedSortedIndex.remove(index)
                }
                currentNumber = null
                inlineClass = null
            }

            override fun updateComposeContext(composeContext: ComposeContext?): ComposeContext? {
                while (expectedSortedIndex.size > 0) {
                    params.add(Parameter(expectedSortedIndex.removeAt(0)))
                }
                return composeContext?.copy(
                    parameters = params
                )
            }

            private fun ensureIndexes(index: Int) {
                val missing = index - lastAdded
                if (missing > 0) {
                    @Suppress("MagicNumber")
                    val minAddAmount = 4
                    val amountToAdd = if (missing < minAddAmount) minAddAmount else missing
                    repeat(amountToAdd) {
                        expectedSortedIndex.add(it + lastAdded + 1)
                    }
                    lastAdded += amountToAdd
                }
            }
        }

        /**
         *  A `:` char in the `sourceInfo` indicates the name of the file with the code for the compose group.
         *
         * It's formatted as `{source_file.kt}#{packageHash}
         *
         * The hash that follows the `#` sign represents a hash code of the package name of the file, in base 36 digits.
         * This can be used to disambiguate which file is referenced by `source_file.kt`.
         */
        class SourceFileTR : TokenReader() {
            var sourceFile: String = ""
            var packageHash: String = ""
            var isReadingHash = false

            override fun process(c: Char) {
                when (c) {
                    '#' -> isReadingHash = true
                    else -> {
                        if (isReadingHash) {
                            packageHash += c
                        } else {
                            sourceFile += c
                        }
                    }
                }
            }

            override fun updateComposeContext(composeContext: ComposeContext?): ComposeContext? {
                return composeContext?.copy(
                    sourceFile = sourceFile,
                    packageHash = packageHash.toIntOrNull(RADIX_BASE_36) ?: -1
                )
            }
        }
    }

    fun parse(raw: String): ComposeContext? {
        var composeContext: ComposeContext? = ComposeContext()
        var i = 0
        var reader: TokenReader = TokenReader.EmptyTR()

        while (i < raw.length) {
            val c = raw[i]
            reader.process(c)
            val nextReader = reader.nextReader()
            if ((nextReader != null)) {
                composeContext = reader.updateComposeContext(composeContext)
                reader = nextReader
            }
            i++
        }

        composeContext = reader.updateComposeContext(composeContext)

        return composeContext
    }
}
